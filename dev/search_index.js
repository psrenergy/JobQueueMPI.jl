var documenterSearchIndex = {"docs":
[{"location":"#JobQueueMPI.jl","page":"Home","title":"JobQueueMPI.jl","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install JobQueueMPI.jl using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add JobQueueMPI","category":"page"},{"location":"#How-it-works","page":"Home","title":"How it works","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First, when running a program using MPI, the user has to set the number of processes that will parallelize the computation. One of these processes will be the controller, and the others will be the workers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can easily delimit the areas of the code that will be executed only by the controller or the worker.","category":"page"},{"location":"","page":"Home","title":"Home","text":"JobQueueMPI.jl has the following components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Controller: The controller is responsible for managing the jobs and the workers. It keeps track of the jobs that have been sent and received and sends the jobs to the available workers.\nWorker: The worker is responsible for executing the jobs. It receives the jobs from the controller, executes them, and sends the results back to the controller.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Users can call functions to compute jobs in parallel in two ways:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building a function and using a pmap implementation that will put the function in the job queue and send it to the workers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JobQueueMPI\n\nfunction sum_100(value)\n    return value + 100\nend\n\nsum_100_answer = JobQueueMPI.pmap(sum_100, collect(1:10))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building the jobs and sending them to workers explicitly. There are examples of this structure in the test folder. This way is much more flexible than the first one, but it requires more code and knowledge about how MPI works.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JobQueueMPI\n\nmutable struct Message\n    value::Int\n    vector_idx::Int\nend\n\nall_jobs_done(controller) = JQM.is_job_queue_empty(controller) && !JQM.any_pending_jobs(controller)\n\nfunction sum_100(message::Message)\n    message.value += 100\n    return message\nend\n\nfunction update_data(new_data, message::Message)\n    idx = message.vector_idx\n    value = message.value\n    return new_data[idx] = value\nend\n\nfunction workers_loop()\n    if JQM.is_worker_process()\n        worker = JQM.Worker()\n        while true\n            job = JQM.receive_job(worker)\n            message = JQM.get_message(job)\n            if message == JQM.TerminationMessage()\n                break\n            end\n            return_message = sum_100(message)\n            JQM.send_job_answer_to_controller(worker, return_message)\n        end\n        exit(0)\n    end\nend\n\nfunction job_queue(data)\n    JQM.mpi_init()\n    JQM.mpi_barrier()\n\n    T = eltype(data)\n    N = length(data)\n\n    if JQM.is_controller_process()\n        new_data = Array{T}(undef, N)\n\n        controller = JQM.Controller(JQM.num_workers())\n\n        for i in eachindex(data)\n            message = Message(data[i], i)\n            JQM.add_job_to_queue!(controller, message)\n        end\n\n        while !all_jobs_done(controller)\n            if !JQM.is_job_queue_empty(controller)\n                JQM.send_jobs_to_any_available_workers(controller)\n            end\n            if JQM.any_pending_jobs(controller)\n                job_answer = JQM.check_for_job_answers(controller)\n                if !isnothing(job_answer)\n                    message = JQM.get_message(job_answer)\n                    update_data(new_data, message)\n                end\n            end\n        end\n\n        JQM.send_termination_message()\n\n        return new_data\n    end\n    workers_loop()\n    JQM.mpi_barrier()\n    JQM.mpi_finalize()\n    return nothing\nend\n\ndata = collect(1:10)\nnew_data = job_queue(data)","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JobQueueMPI.Controller\nJobQueueMPI.Worker\nJobQueueMPI.add_job_to_queue!\nJobQueueMPI.send_jobs_to_any_available_workers\nJobQueueMPI.send_termination_message\nJobQueueMPI.check_for_job_answers\nJobQueueMPI.send_job_answer_to_controller\nJobQueueMPI.receive_job\nJobQueueMPI.get_message\nJobQueueMPI.pmap","category":"page"},{"location":"#JobQueueMPI.Controller","page":"Home","title":"JobQueueMPI.Controller","text":"Controller\n\nThe controller struct is used to manage the workers and the jobs. It keeps track of the workers' status, the job queue, and the pending jobs. It also keeps track of the last job id that was sent to the workers.\n\n\n\n\n\n","category":"type"},{"location":"#JobQueueMPI.Worker","page":"Home","title":"JobQueueMPI.Worker","text":"Worker\n\nA worker process.\n\n\n\n\n\n","category":"type"},{"location":"#JobQueueMPI.add_job_to_queue!","page":"Home","title":"JobQueueMPI.add_job_to_queue!","text":"add_job_to_queue!(controller::Controller, message::Any)\n\nAdd a job to the controller's job queue.\n\n\n\n\n\n","category":"function"},{"location":"#JobQueueMPI.send_jobs_to_any_available_workers","page":"Home","title":"JobQueueMPI.send_jobs_to_any_available_workers","text":"send_jobs_to_any_available_workers(controller::Controller)\n\nSend jobs to any available workers.\n\n\n\n\n\n","category":"function"},{"location":"#JobQueueMPI.send_termination_message","page":"Home","title":"JobQueueMPI.send_termination_message","text":"send_termination_message()\n\nSend a termination message to all workers.\n\n\n\n\n\n","category":"function"},{"location":"#JobQueueMPI.check_for_job_answers","page":"Home","title":"JobQueueMPI.check_for_job_answers","text":"check_for_job_answers(controller::Controller)\n\nCheck if any worker has completed a job and return the answer.\n\n\n\n\n\n","category":"function"},{"location":"#JobQueueMPI.send_job_answer_to_controller","page":"Home","title":"JobQueueMPI.send_job_answer_to_controller","text":"send_job_answer_to_controller(worker::Worker, message)\n\nSend a job answer to the controller process.\n\n\n\n\n\n","category":"function"},{"location":"#JobQueueMPI.receive_job","page":"Home","title":"JobQueueMPI.receive_job","text":"receive_job(worker::Worker)\n\nReceive a job from the controller process.\n\n\n\n\n\n","category":"function"},{"location":"#JobQueueMPI.get_message","page":"Home","title":"JobQueueMPI.get_message","text":"get_message(job::AbstractJob)\n\nGet the message from a job.\n\n\n\n\n\n","category":"function"},{"location":"#JobQueueMPI.pmap","page":"Home","title":"JobQueueMPI.pmap","text":"pmap(\n    f::Function, \n    jobs::Vector, \n    data_defined_in_process = nothing; \n    return_result_in_all_processes::Bool = false\n)\n\nParallel map function that works with MPI. If the function is called in parallel, it will distribute the jobs to the workers and collect the results. If the function is called in serial, it will just map the function to the jobs.\n\nThe function f should take one argument, which is the message to be processed. If data_defined_in_process is not nothing, the function f should take two arguments, the first one being data_defined_in_process.\n\nThe return_result_in_all_processes argument is used to broadcast the result to all processes. If set to true.\n\nThe controller process will return the answer in the same order as the jobs were given. The workers will return nothing.\n\n\n\n\n\n","category":"function"}]
}
